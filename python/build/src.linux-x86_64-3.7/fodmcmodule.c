/* File: fodmcmodule.c
 * This file is auto-generated with f2py (version:2).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: Fri May 15 10:24:45 2020
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include <stdarg.h>
#include "Python.h"
#include "fortranobject.h"
/*need_includes0*/

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *fodmc_error;
static PyObject *fodmc_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
/*need_typedefs*/

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif

#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif

#define rank(var) var ## _Rank
#define shape(var,dim) var ## _Dims[dim]
#define old_rank(var) (PyArray_NDIM((PyArrayObject *)(capi_ ## var ## _tmp)))
#define old_shape(var,dim) PyArray_DIM(((PyArrayObject *)(capi_ ## var ## _tmp)),dim)
#define fshape(var,dim) shape(var,rank(var)-dim-1)
#define len(var) shape(var,0)
#define flen(var) fshape(var,0)
#define old_size(var) PyArray_SIZE((PyArrayObject *)(capi_ ## var ## _tmp))
/* #define index(i) capi_i ## i */
#define slen(var) capi_ ## var ## _len
#define size(var, ...) f2py_size((PyArrayObject *)(capi_ ## var ## _tmp), ## __VA_ARGS__, -1)

#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
static int f2py_size(PyArrayObject* var, ...)
{
  npy_int sz = 0;
  npy_int dim;
  npy_int rank;
  va_list argp;
  va_start(argp, var);
  dim = va_arg(argp, npy_int);
  if (dim==-1)
    {
      sz = PyArray_SIZE(var);
    }
  else
    {
      rank = PyArray_NDIM(var);
      if (dim>=1 && dim<=rank)
        sz = PyArray_DIM(var, dim-1);
      else
        fprintf(stderr, "f2py_size: 2nd argument value=%d fails to satisfy 1<=value<=%d. Result will be 0.\n", dim, rank);
    }
  va_end(argp);
  return sz;
}

static int double_from_pyobj(double* v,PyObject *obj,const char *errmess) {
    PyObject* tmp = NULL;
    if (PyFloat_Check(obj)) {
#ifdef __sgi
        *v = PyFloat_AsDouble(obj);
#else
        *v = PyFloat_AS_DOUBLE(obj);
#endif
        return 1;
    }
    tmp = PyNumber_Float(obj);
    if (tmp) {
#ifdef __sgi
        *v = PyFloat_AsDouble(tmp);
#else
        *v = PyFloat_AS_DOUBLE(tmp);
#endif
        Py_DECREF(tmp);
        return 1;
    }
    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyString_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj,0);
    if (tmp) {
        PyErr_Clear();
        if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = fodmc_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int int_from_pyobj(int* v,PyObject *obj,const char *errmess) {
    PyObject* tmp = NULL;
    if (PyInt_Check(obj)) {
        *v = (int)PyInt_AS_LONG(obj);
        return 1;
    }
    tmp = PyNumber_Int(obj);
    if (tmp) {
        *v = PyInt_AS_LONG(tmp);
        Py_DECREF(tmp);
        return 1;
    }
    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyString_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj,0);
    if (tmp) {
        PyErr_Clear();
        if (int_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = fodmc_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}


/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/********************************* get_guess *********************************/
static char doc_f2py_rout_fodmc_fodmc_get_guess[] = "\
get_guess()\n\nWrapper for ``get_guess``.\
\n";
/*  */
static PyObject *f2py_rout_fodmc_fodmc_get_guess(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":fodmc.fodmc.get_guess",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of get_guess ******************************/

/********************************** mc_step **********************************/
static char doc_f2py_rout_fodmc_fodmc_mc_step[] = "\
rthetaphi2,xyz2 = mc_step(rthetaphi1,center_xyz,stepsize)\n\nWrapper for ``mc_step``.\
\n\nParameters\n----------\n"
"rthetaphi1 : input rank-1 array('d') with bounds (3)\n"
"center_xyz : input rank-1 array('d') with bounds (3)\n"
"stepsize : input float\n"
"\nReturns\n-------\n"
"rthetaphi2 : rank-1 array('d') with bounds (3)\n"
"xyz2 : rank-1 array('d') with bounds (3)";
/*  */
static PyObject *f2py_rout_fodmc_fodmc_mc_step(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *rthetaphi1 = NULL;
  npy_intp rthetaphi1_Dims[1] = {-1};
  const int rthetaphi1_Rank = 1;
  PyArrayObject *capi_rthetaphi1_tmp = NULL;
  int capi_rthetaphi1_intent = 0;
  PyObject *rthetaphi1_capi = Py_None;
  double *center_xyz = NULL;
  npy_intp center_xyz_Dims[1] = {-1};
  const int center_xyz_Rank = 1;
  PyArrayObject *capi_center_xyz_tmp = NULL;
  int capi_center_xyz_intent = 0;
  PyObject *center_xyz_capi = Py_None;
  double *rthetaphi2 = NULL;
  npy_intp rthetaphi2_Dims[1] = {-1};
  const int rthetaphi2_Rank = 1;
  PyArrayObject *capi_rthetaphi2_tmp = NULL;
  int capi_rthetaphi2_intent = 0;
  double *xyz2 = NULL;
  npy_intp xyz2_Dims[1] = {-1};
  const int xyz2_Rank = 1;
  PyArrayObject *capi_xyz2_tmp = NULL;
  int capi_xyz2_intent = 0;
  double stepsize = 0;
  PyObject *stepsize_capi = Py_None;
  static char *capi_kwlist[] = {"rthetaphi1","center_xyz","stepsize",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:fodmc.fodmc.mc_step",\
    capi_kwlist,&rthetaphi1_capi,&center_xyz_capi,&stepsize_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable rthetaphi1 */
  rthetaphi1_Dims[0]=3;
  capi_rthetaphi1_intent |= F2PY_INTENT_IN;
  capi_rthetaphi1_tmp = array_from_pyobj(NPY_DOUBLE,rthetaphi1_Dims,rthetaphi1_Rank,capi_rthetaphi1_intent,rthetaphi1_capi);
  if (capi_rthetaphi1_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 1st argument `rthetaphi1' of fodmc.fodmc.mc_step to C/Fortran array" );
  } else {
    rthetaphi1 = (double *)(PyArray_DATA(capi_rthetaphi1_tmp));

  /* Processing variable center_xyz */
  center_xyz_Dims[0]=3;
  capi_center_xyz_intent |= F2PY_INTENT_IN;
  capi_center_xyz_tmp = array_from_pyobj(NPY_DOUBLE,center_xyz_Dims,center_xyz_Rank,capi_center_xyz_intent,center_xyz_capi);
  if (capi_center_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 2nd argument `center_xyz' of fodmc.fodmc.mc_step to C/Fortran array" );
  } else {
    center_xyz = (double *)(PyArray_DATA(capi_center_xyz_tmp));

  /* Processing variable stepsize */
    f2py_success = double_from_pyobj(&stepsize,stepsize_capi,"fodmc.fodmc.mc_step() 3rd argument (stepsize) can't be converted to double");
  if (f2py_success) {
  /* Processing variable rthetaphi2 */
  rthetaphi2_Dims[0]=3;
  capi_rthetaphi2_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_rthetaphi2_tmp = array_from_pyobj(NPY_DOUBLE,rthetaphi2_Dims,rthetaphi2_Rank,capi_rthetaphi2_intent,Py_None);
  if (capi_rthetaphi2_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting hidden `rthetaphi2' of fodmc.fodmc.mc_step to C/Fortran array" );
  } else {
    rthetaphi2 = (double *)(PyArray_DATA(capi_rthetaphi2_tmp));

  /* Processing variable xyz2 */
  xyz2_Dims[0]=3;
  capi_xyz2_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_xyz2_tmp = array_from_pyobj(NPY_DOUBLE,xyz2_Dims,xyz2_Rank,capi_xyz2_intent,Py_None);
  if (capi_xyz2_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting hidden `xyz2' of fodmc.fodmc.mc_step to C/Fortran array" );
  } else {
    xyz2 = (double *)(PyArray_DATA(capi_xyz2_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(rthetaphi1,center_xyz,rthetaphi2,xyz2,&stepsize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("NN",capi_rthetaphi2_tmp,capi_xyz2_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_xyz2_tmp == NULL) ... else of xyz2*/
  /* End of cleaning variable xyz2 */
  }  /*if (capi_rthetaphi2_tmp == NULL) ... else of rthetaphi2*/
  /* End of cleaning variable rthetaphi2 */
  } /*if (f2py_success) of stepsize*/
  /* End of cleaning variable stepsize */
  if((PyObject *)capi_center_xyz_tmp!=center_xyz_capi) {
    Py_XDECREF(capi_center_xyz_tmp); }
  }  /*if (capi_center_xyz_tmp == NULL) ... else of center_xyz*/
  /* End of cleaning variable center_xyz */
  if((PyObject *)capi_rthetaphi1_tmp!=rthetaphi1_capi) {
    Py_XDECREF(capi_rthetaphi1_tmp); }
  }  /*if (capi_rthetaphi1_tmp == NULL) ... else of rthetaphi1*/
  /* End of cleaning variable rthetaphi1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of mc_step *******************************/

/******************************* create_rotmat *******************************/
static char doc_f2py_rout_fodmc_fodmc_create_rotmat[] = "\
fullrotmat = create_rotmat(stepsize)\n\nWrapper for ``create_rotmat``.\
\n\nParameters\n----------\n"
"stepsize : input float\n"
"\nReturns\n-------\n"
"fullrotmat : rank-2 array('d') with bounds (3,3)";
/*  */
static PyObject *f2py_rout_fodmc_fodmc_create_rotmat(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *fullrotmat = NULL;
  npy_intp fullrotmat_Dims[2] = {-1, -1};
  const int fullrotmat_Rank = 2;
  PyArrayObject *capi_fullrotmat_tmp = NULL;
  int capi_fullrotmat_intent = 0;
  double stepsize = 0;
  PyObject *stepsize_capi = Py_None;
  static char *capi_kwlist[] = {"stepsize",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:fodmc.fodmc.create_rotmat",\
    capi_kwlist,&stepsize_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable stepsize */
    f2py_success = double_from_pyobj(&stepsize,stepsize_capi,"fodmc.fodmc.create_rotmat() 1st argument (stepsize) can't be converted to double");
  if (f2py_success) {
  /* Processing variable fullrotmat */
  fullrotmat_Dims[0]=3,fullrotmat_Dims[1]=3;
  capi_fullrotmat_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_fullrotmat_tmp = array_from_pyobj(NPY_DOUBLE,fullrotmat_Dims,fullrotmat_Rank,capi_fullrotmat_intent,Py_None);
  if (capi_fullrotmat_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting hidden `fullrotmat' of fodmc.fodmc.create_rotmat to C/Fortran array" );
  } else {
    fullrotmat = (double *)(PyArray_DATA(capi_fullrotmat_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(fullrotmat,&stepsize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_fullrotmat_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_fullrotmat_tmp == NULL) ... else of fullrotmat*/
  /* End of cleaning variable fullrotmat */
  } /*if (f2py_success) of stepsize*/
  /* End of cleaning variable stepsize */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of create_rotmat ****************************/

/***************************** create_rotmat_bond *****************************/
static char doc_f2py_rout_fodmc_fodmc_create_rotmat_bond[] = "\
fullrotmat = create_rotmat_bond(axis_vector,stepsize)\n\nWrapper for ``create_rotmat_bond``.\
\n\nParameters\n----------\n"
"axis_vector : input rank-1 array('d') with bounds (3)\n"
"stepsize : input float\n"
"\nReturns\n-------\n"
"fullrotmat : rank-2 array('d') with bounds (3,3)";
/*  */
static PyObject *f2py_rout_fodmc_fodmc_create_rotmat_bond(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *fullrotmat = NULL;
  npy_intp fullrotmat_Dims[2] = {-1, -1};
  const int fullrotmat_Rank = 2;
  PyArrayObject *capi_fullrotmat_tmp = NULL;
  int capi_fullrotmat_intent = 0;
  double *axis_vector = NULL;
  npy_intp axis_vector_Dims[1] = {-1};
  const int axis_vector_Rank = 1;
  PyArrayObject *capi_axis_vector_tmp = NULL;
  int capi_axis_vector_intent = 0;
  PyObject *axis_vector_capi = Py_None;
  double stepsize = 0;
  PyObject *stepsize_capi = Py_None;
  static char *capi_kwlist[] = {"axis_vector","stepsize",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:fodmc.fodmc.create_rotmat_bond",\
    capi_kwlist,&axis_vector_capi,&stepsize_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable stepsize */
    f2py_success = double_from_pyobj(&stepsize,stepsize_capi,"fodmc.fodmc.create_rotmat_bond() 2nd argument (stepsize) can't be converted to double");
  if (f2py_success) {
  /* Processing variable axis_vector */
  axis_vector_Dims[0]=3;
  capi_axis_vector_intent |= F2PY_INTENT_IN;
  capi_axis_vector_tmp = array_from_pyobj(NPY_DOUBLE,axis_vector_Dims,axis_vector_Rank,capi_axis_vector_intent,axis_vector_capi);
  if (capi_axis_vector_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 1st argument `axis_vector' of fodmc.fodmc.create_rotmat_bond to C/Fortran array" );
  } else {
    axis_vector = (double *)(PyArray_DATA(capi_axis_vector_tmp));

  /* Processing variable fullrotmat */
  fullrotmat_Dims[0]=3,fullrotmat_Dims[1]=3;
  capi_fullrotmat_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_fullrotmat_tmp = array_from_pyobj(NPY_DOUBLE,fullrotmat_Dims,fullrotmat_Rank,capi_fullrotmat_intent,Py_None);
  if (capi_fullrotmat_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting hidden `fullrotmat' of fodmc.fodmc.create_rotmat_bond to C/Fortran array" );
  } else {
    fullrotmat = (double *)(PyArray_DATA(capi_fullrotmat_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(fullrotmat,axis_vector,&stepsize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_fullrotmat_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_fullrotmat_tmp == NULL) ... else of fullrotmat*/
  /* End of cleaning variable fullrotmat */
  if((PyObject *)capi_axis_vector_tmp!=axis_vector_capi) {
    Py_XDECREF(capi_axis_vector_tmp); }
  }  /*if (capi_axis_vector_tmp == NULL) ... else of axis_vector*/
  /* End of cleaning variable axis_vector */
  } /*if (f2py_success) of stepsize*/
  /* End of cleaning variable stepsize */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of create_rotmat_bond *************************/

/********************************* rotate_pos *********************************/
static char doc_f2py_rout_fodmc_fodmc_rotate_pos[] = "\
xyz2 = rotate_pos(fullrotmat,xyz1,center_xyz)\n\nWrapper for ``rotate_pos``.\
\n\nParameters\n----------\n"
"fullrotmat : input rank-2 array('d') with bounds (3,3)\n"
"xyz1 : input rank-1 array('d') with bounds (3)\n"
"center_xyz : input rank-1 array('d') with bounds (3)\n"
"\nReturns\n-------\n"
"xyz2 : rank-1 array('d') with bounds (3)";
/*  */
static PyObject *f2py_rout_fodmc_fodmc_rotate_pos(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *fullrotmat = NULL;
  npy_intp fullrotmat_Dims[2] = {-1, -1};
  const int fullrotmat_Rank = 2;
  PyArrayObject *capi_fullrotmat_tmp = NULL;
  int capi_fullrotmat_intent = 0;
  PyObject *fullrotmat_capi = Py_None;
  double *xyz1 = NULL;
  npy_intp xyz1_Dims[1] = {-1};
  const int xyz1_Rank = 1;
  PyArrayObject *capi_xyz1_tmp = NULL;
  int capi_xyz1_intent = 0;
  PyObject *xyz1_capi = Py_None;
  double *center_xyz = NULL;
  npy_intp center_xyz_Dims[1] = {-1};
  const int center_xyz_Rank = 1;
  PyArrayObject *capi_center_xyz_tmp = NULL;
  int capi_center_xyz_intent = 0;
  PyObject *center_xyz_capi = Py_None;
  double *xyz2 = NULL;
  npy_intp xyz2_Dims[1] = {-1};
  const int xyz2_Rank = 1;
  PyArrayObject *capi_xyz2_tmp = NULL;
  int capi_xyz2_intent = 0;
  static char *capi_kwlist[] = {"fullrotmat","xyz1","center_xyz",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:fodmc.fodmc.rotate_pos",\
    capi_kwlist,&fullrotmat_capi,&xyz1_capi,&center_xyz_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable fullrotmat */
  fullrotmat_Dims[0]=3,fullrotmat_Dims[1]=3;
  capi_fullrotmat_intent |= F2PY_INTENT_IN;
  capi_fullrotmat_tmp = array_from_pyobj(NPY_DOUBLE,fullrotmat_Dims,fullrotmat_Rank,capi_fullrotmat_intent,fullrotmat_capi);
  if (capi_fullrotmat_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 1st argument `fullrotmat' of fodmc.fodmc.rotate_pos to C/Fortran array" );
  } else {
    fullrotmat = (double *)(PyArray_DATA(capi_fullrotmat_tmp));

  /* Processing variable xyz1 */
  xyz1_Dims[0]=3;
  capi_xyz1_intent |= F2PY_INTENT_IN;
  capi_xyz1_tmp = array_from_pyobj(NPY_DOUBLE,xyz1_Dims,xyz1_Rank,capi_xyz1_intent,xyz1_capi);
  if (capi_xyz1_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 2nd argument `xyz1' of fodmc.fodmc.rotate_pos to C/Fortran array" );
  } else {
    xyz1 = (double *)(PyArray_DATA(capi_xyz1_tmp));

  /* Processing variable center_xyz */
  center_xyz_Dims[0]=3;
  capi_center_xyz_intent |= F2PY_INTENT_IN;
  capi_center_xyz_tmp = array_from_pyobj(NPY_DOUBLE,center_xyz_Dims,center_xyz_Rank,capi_center_xyz_intent,center_xyz_capi);
  if (capi_center_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 3rd argument `center_xyz' of fodmc.fodmc.rotate_pos to C/Fortran array" );
  } else {
    center_xyz = (double *)(PyArray_DATA(capi_center_xyz_tmp));

  /* Processing variable xyz2 */
  xyz2_Dims[0]=3;
  capi_xyz2_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_xyz2_tmp = array_from_pyobj(NPY_DOUBLE,xyz2_Dims,xyz2_Rank,capi_xyz2_intent,Py_None);
  if (capi_xyz2_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting hidden `xyz2' of fodmc.fodmc.rotate_pos to C/Fortran array" );
  } else {
    xyz2 = (double *)(PyArray_DATA(capi_xyz2_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(fullrotmat,xyz1,center_xyz,xyz2);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_xyz2_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_xyz2_tmp == NULL) ... else of xyz2*/
  /* End of cleaning variable xyz2 */
  if((PyObject *)capi_center_xyz_tmp!=center_xyz_capi) {
    Py_XDECREF(capi_center_xyz_tmp); }
  }  /*if (capi_center_xyz_tmp == NULL) ... else of center_xyz*/
  /* End of cleaning variable center_xyz */
  if((PyObject *)capi_xyz1_tmp!=xyz1_capi) {
    Py_XDECREF(capi_xyz1_tmp); }
  }  /*if (capi_xyz1_tmp == NULL) ... else of xyz1*/
  /* End of cleaning variable xyz1 */
  if((PyObject *)capi_fullrotmat_tmp!=fullrotmat_capi) {
    Py_XDECREF(capi_fullrotmat_tmp); }
  }  /*if (capi_fullrotmat_tmp == NULL) ... else of fullrotmat*/
  /* End of cleaning variable fullrotmat */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of rotate_pos *****************************/

/***************************** rotate_around_axis *****************************/
static char doc_f2py_rout_fodmc_fodmc_rotate_around_axis[] = "\
rotate_around_axis(axis_vector,center_of_bond,xyz,stepsize)\n\nWrapper for ``rotate_around_axis``.\
\n\nParameters\n----------\n"
"axis_vector : input rank-1 array('d') with bounds (3)\n"
"center_of_bond : input rank-1 array('d') with bounds (3)\n"
"xyz : in/output rank-1 array('d') with bounds (3)\n"
"stepsize : input float";
/*  */
static PyObject *f2py_rout_fodmc_fodmc_rotate_around_axis(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *axis_vector = NULL;
  npy_intp axis_vector_Dims[1] = {-1};
  const int axis_vector_Rank = 1;
  PyArrayObject *capi_axis_vector_tmp = NULL;
  int capi_axis_vector_intent = 0;
  PyObject *axis_vector_capi = Py_None;
  double *center_of_bond = NULL;
  npy_intp center_of_bond_Dims[1] = {-1};
  const int center_of_bond_Rank = 1;
  PyArrayObject *capi_center_of_bond_tmp = NULL;
  int capi_center_of_bond_intent = 0;
  PyObject *center_of_bond_capi = Py_None;
  double *xyz = NULL;
  npy_intp xyz_Dims[1] = {-1};
  const int xyz_Rank = 1;
  PyArrayObject *capi_xyz_tmp = NULL;
  int capi_xyz_intent = 0;
  PyObject *xyz_capi = Py_None;
  double stepsize = 0;
  PyObject *stepsize_capi = Py_None;
  static char *capi_kwlist[] = {"axis_vector","center_of_bond","xyz","stepsize",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:fodmc.fodmc.rotate_around_axis",\
    capi_kwlist,&axis_vector_capi,&center_of_bond_capi,&xyz_capi,&stepsize_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable axis_vector */
  axis_vector_Dims[0]=3;
  capi_axis_vector_intent |= F2PY_INTENT_IN;
  capi_axis_vector_tmp = array_from_pyobj(NPY_DOUBLE,axis_vector_Dims,axis_vector_Rank,capi_axis_vector_intent,axis_vector_capi);
  if (capi_axis_vector_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 1st argument `axis_vector' of fodmc.fodmc.rotate_around_axis to C/Fortran array" );
  } else {
    axis_vector = (double *)(PyArray_DATA(capi_axis_vector_tmp));

  /* Processing variable center_of_bond */
  center_of_bond_Dims[0]=3;
  capi_center_of_bond_intent |= F2PY_INTENT_IN;
  capi_center_of_bond_tmp = array_from_pyobj(NPY_DOUBLE,center_of_bond_Dims,center_of_bond_Rank,capi_center_of_bond_intent,center_of_bond_capi);
  if (capi_center_of_bond_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 2nd argument `center_of_bond' of fodmc.fodmc.rotate_around_axis to C/Fortran array" );
  } else {
    center_of_bond = (double *)(PyArray_DATA(capi_center_of_bond_tmp));

  /* Processing variable stepsize */
    f2py_success = double_from_pyobj(&stepsize,stepsize_capi,"fodmc.fodmc.rotate_around_axis() 4th argument (stepsize) can't be converted to double");
  if (f2py_success) {
  /* Processing variable xyz */
  xyz_Dims[0]=3;
  capi_xyz_intent |= F2PY_INTENT_INOUT;
  capi_xyz_tmp = array_from_pyobj(NPY_DOUBLE,xyz_Dims,xyz_Rank,capi_xyz_intent,xyz_capi);
  if (capi_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 3rd argument `xyz' of fodmc.fodmc.rotate_around_axis to C/Fortran array" );
  } else {
    xyz = (double *)(PyArray_DATA(capi_xyz_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(axis_vector,center_of_bond,xyz,&stepsize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_xyz_tmp!=xyz_capi) {
    Py_XDECREF(capi_xyz_tmp); }
  }  /*if (capi_xyz_tmp == NULL) ... else of xyz*/
  /* End of cleaning variable xyz */
  } /*if (f2py_success) of stepsize*/
  /* End of cleaning variable stepsize */
  if((PyObject *)capi_center_of_bond_tmp!=center_of_bond_capi) {
    Py_XDECREF(capi_center_of_bond_tmp); }
  }  /*if (capi_center_of_bond_tmp == NULL) ... else of center_of_bond*/
  /* End of cleaning variable center_of_bond */
  if((PyObject *)capi_axis_vector_tmp!=axis_vector_capi) {
    Py_XDECREF(capi_axis_vector_tmp); }
  }  /*if (capi_axis_vector_tmp == NULL) ... else of axis_vector*/
  /* End of cleaning variable axis_vector */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of rotate_around_axis *************************/

/********************************* per_vector *********************************/
static char doc_f2py_rout_fodmc_fodmc_per_vector[] = "\
per_vector(bond_vec,center_xyz,per_vec)\n\nWrapper for ``per_vector``.\
\n\nParameters\n----------\n"
"bond_vec : input rank-1 array('d') with bounds (3)\n"
"center_xyz : input rank-1 array('d') with bounds (3)\n"
"per_vec : in/output rank-1 array('d') with bounds (3)";
/*  */
static PyObject *f2py_rout_fodmc_fodmc_per_vector(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *bond_vec = NULL;
  npy_intp bond_vec_Dims[1] = {-1};
  const int bond_vec_Rank = 1;
  PyArrayObject *capi_bond_vec_tmp = NULL;
  int capi_bond_vec_intent = 0;
  PyObject *bond_vec_capi = Py_None;
  double *center_xyz = NULL;
  npy_intp center_xyz_Dims[1] = {-1};
  const int center_xyz_Rank = 1;
  PyArrayObject *capi_center_xyz_tmp = NULL;
  int capi_center_xyz_intent = 0;
  PyObject *center_xyz_capi = Py_None;
  double *per_vec = NULL;
  npy_intp per_vec_Dims[1] = {-1};
  const int per_vec_Rank = 1;
  PyArrayObject *capi_per_vec_tmp = NULL;
  int capi_per_vec_intent = 0;
  PyObject *per_vec_capi = Py_None;
  static char *capi_kwlist[] = {"bond_vec","center_xyz","per_vec",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:fodmc.fodmc.per_vector",\
    capi_kwlist,&bond_vec_capi,&center_xyz_capi,&per_vec_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable bond_vec */
  bond_vec_Dims[0]=3;
  capi_bond_vec_intent |= F2PY_INTENT_IN;
  capi_bond_vec_tmp = array_from_pyobj(NPY_DOUBLE,bond_vec_Dims,bond_vec_Rank,capi_bond_vec_intent,bond_vec_capi);
  if (capi_bond_vec_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 1st argument `bond_vec' of fodmc.fodmc.per_vector to C/Fortran array" );
  } else {
    bond_vec = (double *)(PyArray_DATA(capi_bond_vec_tmp));

  /* Processing variable center_xyz */
  center_xyz_Dims[0]=3;
  capi_center_xyz_intent |= F2PY_INTENT_IN;
  capi_center_xyz_tmp = array_from_pyobj(NPY_DOUBLE,center_xyz_Dims,center_xyz_Rank,capi_center_xyz_intent,center_xyz_capi);
  if (capi_center_xyz_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 2nd argument `center_xyz' of fodmc.fodmc.per_vector to C/Fortran array" );
  } else {
    center_xyz = (double *)(PyArray_DATA(capi_center_xyz_tmp));

  /* Processing variable per_vec */
  per_vec_Dims[0]=3;
  capi_per_vec_intent |= F2PY_INTENT_INOUT;
  capi_per_vec_tmp = array_from_pyobj(NPY_DOUBLE,per_vec_Dims,per_vec_Rank,capi_per_vec_intent,per_vec_capi);
  if (capi_per_vec_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 3rd argument `per_vec' of fodmc.fodmc.per_vector to C/Fortran array" );
  } else {
    per_vec = (double *)(PyArray_DATA(capi_per_vec_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(bond_vec,center_xyz,per_vec);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_per_vec_tmp!=per_vec_capi) {
    Py_XDECREF(capi_per_vec_tmp); }
  }  /*if (capi_per_vec_tmp == NULL) ... else of per_vec*/
  /* End of cleaning variable per_vec */
  if((PyObject *)capi_center_xyz_tmp!=center_xyz_capi) {
    Py_XDECREF(capi_center_xyz_tmp); }
  }  /*if (capi_center_xyz_tmp == NULL) ... else of center_xyz*/
  /* End of cleaning variable center_xyz */
  if((PyObject *)capi_bond_vec_tmp!=bond_vec_capi) {
    Py_XDECREF(capi_bond_vec_tmp); }
  }  /*if (capi_bond_vec_tmp == NULL) ... else of bond_vec*/
  /* End of cleaning variable bond_vec */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of per_vector *****************************/

/******************************** cart_to_frac ********************************/
static char doc_f2py_rout_fodmc_fodmc_cart_to_frac[] = "\
cart_to_frac(veca,vecb,vecc,pos_cart,pos_frac)\n\nWrapper for ``cart_to_frac``.\
\n\nParameters\n----------\n"
"veca : input rank-1 array('d') with bounds (3)\n"
"vecb : input rank-1 array('d') with bounds (3)\n"
"vecc : input rank-1 array('d') with bounds (3)\n"
"pos_cart : in/output rank-1 array('d') with bounds (3)\n"
"pos_frac : in/output rank-1 array('d') with bounds (3)";
/*  */
static PyObject *f2py_rout_fodmc_fodmc_cart_to_frac(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *veca = NULL;
  npy_intp veca_Dims[1] = {-1};
  const int veca_Rank = 1;
  PyArrayObject *capi_veca_tmp = NULL;
  int capi_veca_intent = 0;
  PyObject *veca_capi = Py_None;
  double *vecb = NULL;
  npy_intp vecb_Dims[1] = {-1};
  const int vecb_Rank = 1;
  PyArrayObject *capi_vecb_tmp = NULL;
  int capi_vecb_intent = 0;
  PyObject *vecb_capi = Py_None;
  double *vecc = NULL;
  npy_intp vecc_Dims[1] = {-1};
  const int vecc_Rank = 1;
  PyArrayObject *capi_vecc_tmp = NULL;
  int capi_vecc_intent = 0;
  PyObject *vecc_capi = Py_None;
  double *pos_cart = NULL;
  npy_intp pos_cart_Dims[1] = {-1};
  const int pos_cart_Rank = 1;
  PyArrayObject *capi_pos_cart_tmp = NULL;
  int capi_pos_cart_intent = 0;
  PyObject *pos_cart_capi = Py_None;
  double *pos_frac = NULL;
  npy_intp pos_frac_Dims[1] = {-1};
  const int pos_frac_Rank = 1;
  PyArrayObject *capi_pos_frac_tmp = NULL;
  int capi_pos_frac_intent = 0;
  PyObject *pos_frac_capi = Py_None;
  static char *capi_kwlist[] = {"veca","vecb","vecc","pos_cart","pos_frac",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO:fodmc.fodmc.cart_to_frac",\
    capi_kwlist,&veca_capi,&vecb_capi,&vecc_capi,&pos_cart_capi,&pos_frac_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable veca */
  veca_Dims[0]=3;
  capi_veca_intent |= F2PY_INTENT_IN;
  capi_veca_tmp = array_from_pyobj(NPY_DOUBLE,veca_Dims,veca_Rank,capi_veca_intent,veca_capi);
  if (capi_veca_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 1st argument `veca' of fodmc.fodmc.cart_to_frac to C/Fortran array" );
  } else {
    veca = (double *)(PyArray_DATA(capi_veca_tmp));

  /* Processing variable vecb */
  vecb_Dims[0]=3;
  capi_vecb_intent |= F2PY_INTENT_IN;
  capi_vecb_tmp = array_from_pyobj(NPY_DOUBLE,vecb_Dims,vecb_Rank,capi_vecb_intent,vecb_capi);
  if (capi_vecb_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 2nd argument `vecb' of fodmc.fodmc.cart_to_frac to C/Fortran array" );
  } else {
    vecb = (double *)(PyArray_DATA(capi_vecb_tmp));

  /* Processing variable vecc */
  vecc_Dims[0]=3;
  capi_vecc_intent |= F2PY_INTENT_IN;
  capi_vecc_tmp = array_from_pyobj(NPY_DOUBLE,vecc_Dims,vecc_Rank,capi_vecc_intent,vecc_capi);
  if (capi_vecc_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 3rd argument `vecc' of fodmc.fodmc.cart_to_frac to C/Fortran array" );
  } else {
    vecc = (double *)(PyArray_DATA(capi_vecc_tmp));

  /* Processing variable pos_cart */
  pos_cart_Dims[0]=3;
  capi_pos_cart_intent |= F2PY_INTENT_INOUT;
  capi_pos_cart_tmp = array_from_pyobj(NPY_DOUBLE,pos_cart_Dims,pos_cart_Rank,capi_pos_cart_intent,pos_cart_capi);
  if (capi_pos_cart_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 4th argument `pos_cart' of fodmc.fodmc.cart_to_frac to C/Fortran array" );
  } else {
    pos_cart = (double *)(PyArray_DATA(capi_pos_cart_tmp));

  /* Processing variable pos_frac */
  pos_frac_Dims[0]=3;
  capi_pos_frac_intent |= F2PY_INTENT_INOUT;
  capi_pos_frac_tmp = array_from_pyobj(NPY_DOUBLE,pos_frac_Dims,pos_frac_Rank,capi_pos_frac_intent,pos_frac_capi);
  if (capi_pos_frac_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 5th argument `pos_frac' of fodmc.fodmc.cart_to_frac to C/Fortran array" );
  } else {
    pos_frac = (double *)(PyArray_DATA(capi_pos_frac_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(veca,vecb,vecc,pos_cart,pos_frac);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_pos_frac_tmp!=pos_frac_capi) {
    Py_XDECREF(capi_pos_frac_tmp); }
  }  /*if (capi_pos_frac_tmp == NULL) ... else of pos_frac*/
  /* End of cleaning variable pos_frac */
  if((PyObject *)capi_pos_cart_tmp!=pos_cart_capi) {
    Py_XDECREF(capi_pos_cart_tmp); }
  }  /*if (capi_pos_cart_tmp == NULL) ... else of pos_cart*/
  /* End of cleaning variable pos_cart */
  if((PyObject *)capi_vecc_tmp!=vecc_capi) {
    Py_XDECREF(capi_vecc_tmp); }
  }  /*if (capi_vecc_tmp == NULL) ... else of vecc*/
  /* End of cleaning variable vecc */
  if((PyObject *)capi_vecb_tmp!=vecb_capi) {
    Py_XDECREF(capi_vecb_tmp); }
  }  /*if (capi_vecb_tmp == NULL) ... else of vecb*/
  /* End of cleaning variable vecb */
  if((PyObject *)capi_veca_tmp!=veca_capi) {
    Py_XDECREF(capi_veca_tmp); }
  }  /*if (capi_veca_tmp == NULL) ... else of veca*/
  /* End of cleaning variable veca */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of cart_to_frac ****************************/

/******************************** struct_motif ********************************/
static char doc_f2py_rout_fodmc_fodmc_struct_motif[] = "\
struct_motif(n_point_tot,n_point,radius,nuc_pos,position_point)\n\nWrapper for ``struct_motif``.\
\n\nParameters\n----------\n"
"n_point_tot : input int\n"
"n_point : input int\n"
"radius : input float\n"
"nuc_pos : input rank-1 array('d') with bounds (3)\n"
"position_point : in/output rank-1 array('d') with bounds (3)";
/*  */
static PyObject *f2py_rout_fodmc_fodmc_struct_motif(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int n_point_tot = 0;
  PyObject *n_point_tot_capi = Py_None;
  int n_point = 0;
  PyObject *n_point_capi = Py_None;
  double radius = 0;
  PyObject *radius_capi = Py_None;
  double *nuc_pos = NULL;
  npy_intp nuc_pos_Dims[1] = {-1};
  const int nuc_pos_Rank = 1;
  PyArrayObject *capi_nuc_pos_tmp = NULL;
  int capi_nuc_pos_intent = 0;
  PyObject *nuc_pos_capi = Py_None;
  double *position_point = NULL;
  npy_intp position_point_Dims[1] = {-1};
  const int position_point_Rank = 1;
  PyArrayObject *capi_position_point_tmp = NULL;
  int capi_position_point_intent = 0;
  PyObject *position_point_capi = Py_None;
  static char *capi_kwlist[] = {"n_point_tot","n_point","radius","nuc_pos","position_point",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO:fodmc.fodmc.struct_motif",\
    capi_kwlist,&n_point_tot_capi,&n_point_capi,&radius_capi,&nuc_pos_capi,&position_point_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n_point_tot */
    f2py_success = int_from_pyobj(&n_point_tot,n_point_tot_capi,"fodmc.fodmc.struct_motif() 1st argument (n_point_tot) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n_point */
    f2py_success = int_from_pyobj(&n_point,n_point_capi,"fodmc.fodmc.struct_motif() 2nd argument (n_point) can't be converted to int");
  if (f2py_success) {
  /* Processing variable radius */
    f2py_success = double_from_pyobj(&radius,radius_capi,"fodmc.fodmc.struct_motif() 3rd argument (radius) can't be converted to double");
  if (f2py_success) {
  /* Processing variable nuc_pos */
  nuc_pos_Dims[0]=3;
  capi_nuc_pos_intent |= F2PY_INTENT_IN;
  capi_nuc_pos_tmp = array_from_pyobj(NPY_DOUBLE,nuc_pos_Dims,nuc_pos_Rank,capi_nuc_pos_intent,nuc_pos_capi);
  if (capi_nuc_pos_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 4th argument `nuc_pos' of fodmc.fodmc.struct_motif to C/Fortran array" );
  } else {
    nuc_pos = (double *)(PyArray_DATA(capi_nuc_pos_tmp));

  /* Processing variable position_point */
  position_point_Dims[0]=3;
  capi_position_point_intent |= F2PY_INTENT_INOUT;
  capi_position_point_tmp = array_from_pyobj(NPY_DOUBLE,position_point_Dims,position_point_Rank,capi_position_point_intent,position_point_capi);
  if (capi_position_point_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(fodmc_error,"failed in converting 5th argument `position_point' of fodmc.fodmc.struct_motif to C/Fortran array" );
  } else {
    position_point = (double *)(PyArray_DATA(capi_position_point_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&n_point_tot,&n_point,&radius,nuc_pos,position_point);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_position_point_tmp!=position_point_capi) {
    Py_XDECREF(capi_position_point_tmp); }
  }  /*if (capi_position_point_tmp == NULL) ... else of position_point*/
  /* End of cleaning variable position_point */
  if((PyObject *)capi_nuc_pos_tmp!=nuc_pos_capi) {
    Py_XDECREF(capi_nuc_pos_tmp); }
  }  /*if (capi_nuc_pos_tmp == NULL) ... else of nuc_pos*/
  /* End of cleaning variable nuc_pos */
  } /*if (f2py_success) of radius*/
  /* End of cleaning variable radius */
  } /*if (f2py_success) of n_point*/
  /* End of cleaning variable n_point */
  } /*if (f2py_success) of n_point_tot*/
  /* End of cleaning variable n_point_tot */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of struct_motif ****************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/

static FortranDataDef f2py_fodmc_def[] = {
  {"get_guess",-1,{{-1}},0,NULL,(void *)f2py_rout_fodmc_fodmc_get_guess,doc_f2py_rout_fodmc_fodmc_get_guess},
  {"mc_step",-1,{{-1}},0,NULL,(void *)f2py_rout_fodmc_fodmc_mc_step,doc_f2py_rout_fodmc_fodmc_mc_step},
  {"create_rotmat",-1,{{-1}},0,NULL,(void *)f2py_rout_fodmc_fodmc_create_rotmat,doc_f2py_rout_fodmc_fodmc_create_rotmat},
  {"create_rotmat_bond",-1,{{-1}},0,NULL,(void *)f2py_rout_fodmc_fodmc_create_rotmat_bond,doc_f2py_rout_fodmc_fodmc_create_rotmat_bond},
  {"rotate_pos",-1,{{-1}},0,NULL,(void *)f2py_rout_fodmc_fodmc_rotate_pos,doc_f2py_rout_fodmc_fodmc_rotate_pos},
  {"rotate_around_axis",-1,{{-1}},0,NULL,(void *)f2py_rout_fodmc_fodmc_rotate_around_axis,doc_f2py_rout_fodmc_fodmc_rotate_around_axis},
  {"per_vector",-1,{{-1}},0,NULL,(void *)f2py_rout_fodmc_fodmc_per_vector,doc_f2py_rout_fodmc_fodmc_per_vector},
  {"cart_to_frac",-1,{{-1}},0,NULL,(void *)f2py_rout_fodmc_fodmc_cart_to_frac,doc_f2py_rout_fodmc_fodmc_cart_to_frac},
  {"struct_motif",-1,{{-1}},0,NULL,(void *)f2py_rout_fodmc_fodmc_struct_motif,doc_f2py_rout_fodmc_fodmc_struct_motif},
  {NULL}
};

static void f2py_setup_fodmc(char *get_guess,char *mc_step,char *create_rotmat,char *create_rotmat_bond,char *rotate_pos,char *rotate_around_axis,char *per_vector,char *cart_to_frac,char *struct_motif) {
  int i_f2py=0;
  f2py_fodmc_def[i_f2py++].data = get_guess;
  f2py_fodmc_def[i_f2py++].data = mc_step;
  f2py_fodmc_def[i_f2py++].data = create_rotmat;
  f2py_fodmc_def[i_f2py++].data = create_rotmat_bond;
  f2py_fodmc_def[i_f2py++].data = rotate_pos;
  f2py_fodmc_def[i_f2py++].data = rotate_around_axis;
  f2py_fodmc_def[i_f2py++].data = per_vector;
  f2py_fodmc_def[i_f2py++].data = cart_to_frac;
  f2py_fodmc_def[i_f2py++].data = struct_motif;
}
extern void F_FUNC(f2pyinitfodmc,F2PYINITFODMC)(void (*)(char *,char *,char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_fodmc(void) {
  F_FUNC(f2pyinitfodmc,F2PYINITFODMC)(f2py_setup_fodmc);
}

/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {

/*eof routine_defs*/
  {NULL}
};

static PyMethodDef f2py_module_methods[] = {

  {NULL,NULL}
};

#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef moduledef = {
  PyModuleDef_HEAD_INIT,
  "fodmc",
  NULL,
  -1,
  f2py_module_methods,
  NULL,
  NULL,
  NULL,
  NULL
};
#endif

#if PY_VERSION_HEX >= 0x03000000
#define RETVAL m
PyMODINIT_FUNC PyInit_fodmc(void) {
#else
#define RETVAL
PyMODINIT_FUNC initfodmc(void) {
#endif
  int i;
  PyObject *m,*d, *s, *tmp;
#if PY_VERSION_HEX >= 0x03000000
  m = fodmc_module = PyModule_Create(&moduledef);
#else
  m = fodmc_module = Py_InitModule("fodmc", f2py_module_methods);
#endif
  Py_TYPE(&PyFortran_Type) = &PyType_Type;
  import_array();
  if (PyErr_Occurred())
    {PyErr_SetString(PyExc_ImportError, "can't initialize module fodmc (failed to import numpy)"); return RETVAL;}
  d = PyModule_GetDict(m);
  s = PyString_FromString("$Revision: $");
  PyDict_SetItemString(d, "__version__", s);
  Py_DECREF(s);
#if PY_VERSION_HEX >= 0x03000000
  s = PyUnicode_FromString(
#else
  s = PyString_FromString(
#endif
    "This module 'fodmc' is auto-generated with f2py (version:2).\nFunctions:\n"
"Fortran 90/95 modules:\n""  fodmc --- get_guess(),mc_step(),create_rotmat(),create_rotmat_bond(),rotate_pos(),rotate_around_axis(),per_vector(),cart_to_frac(),struct_motif()"".");
  PyDict_SetItemString(d, "__doc__", s);
  Py_DECREF(s);
  fodmc_error = PyErr_NewException ("fodmc.error", NULL, NULL);
  /*
   * Store the error object inside the dict, so that it could get deallocated.
   * (in practice, this is a module, so it likely will not and cannot.)
   */
  PyDict_SetItemString(d, "_fodmc_error", fodmc_error);
  Py_DECREF(fodmc_error);
  for(i=0;f2py_routine_defs[i].name!=NULL;i++) {
    tmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
    PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
    Py_DECREF(tmp);
  }









/*eof initf2pywraphooks*/
  PyDict_SetItemString(d, "fodmc", PyFortranObject_New(f2py_fodmc_def,f2py_init_fodmc));
/*eof initf90modhooks*/

/*eof initcommonhooks*/


#ifdef F2PY_REPORT_ATEXIT
  if (! PyErr_Occurred())
    on_exit(f2py_report_on_exit,(void*)"fodmc");
#endif
  return RETVAL;
}
#ifdef __cplusplus
}
#endif
